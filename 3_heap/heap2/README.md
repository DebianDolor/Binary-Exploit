# Analysis

* We are given with the below source code:

    ![image.png](./image.png)
    
* It says: "This level examines what can happen when heap pointers are stale". This introduces us a new type of vulnerablity: <span style="color:red">*use-after-free*</span>:

    ![image-1.png](./image-1.png)

* Let me run this:

    ![image-2.png](./image-2.png)

* Looks like the <span style="color:red">*auth*</span> still points to the original memory location after the <span style="color:red">*reset*</span> command (which calls <span style="color:red">*free(auth)*</span>). The <span style="color:red">*login*</span> command then accesses the freed memory with <span style="color:red">*auth->auth*</span>. 

* Our goal here is to have the program print "you have logged in already!". Which means we have to overwrite the original struct's <span style="color:red">*auth*</span> member with a number other than 0.

* But how can we set the "auth" integer if it isn't referenced anywhere in the program? We could try to overflow the "name" variable, but the bounds checking is pretty tight (the "if(strlen(line + 5) < 31)" check).

# Exploit

* From the given code, I know that the <span style="color:red">*auth*</span> command will allocate space for the <span style="color:red">*auth*</span>'s struct. 

* <span style="color:red">*reset*</span> will free it, and <span style="color:red">*service*</span> will allocate memory on the heap of the duplicated string by the <span style="color:red">*strdup()*</span> function:

    ![image-3.png](./image-3.png)

* Okay, so what if we do the <span style="color:red">*auth*</span>, then the <span style="color:red">*reset*</span>, then the <span style="color:red">*service*</span>?

    - First, it will allocate space for <span style="color:red">*auth*</span>'s struct.

    - Then it will free it

    - Then it will allocate a new chunk of memory for the duplicated string we supply. But where specifically is that allocated space?

    - If u remember, heap chunks are assigned on a "best fit" basis, which means if one is freed, the new allocated memory location will be the same as the freed one, since there are no chunks in use!

        ![image-8.png](./image-8.png)

    - So after the <span style="color:red">*service*</span> command, the location will be the same as the freed one:

        ![image-4.png](./image-4.png)

    - See, this is different from the time we didn't put <span style="color:red">*reset*</span> in between <span style="color:red">*auth*</span> and <span style="color:red">*service*</span>:

        ![image-6.png](./image-6.png)

* With that being said, after using <span style="color:red">*auth*</span> and <span style="color:red">*create*</span>, <span style="color:red">*auth*</span> still has its pointer. And if we call <span style="color:red">*service*</span> right after that, they will point to the same location in the memory!

* This means that, if we enter <span style="color:red">*service*</span> with a long enough input to be copied via strdup, we can overwrite the struct's <span style="color:red">* auth*</span>. Remember, "auth->auth" is interpreted as "the pointer to the struct 'auth' plus an offset of 32 bytes which is where integer auth is expected to be". 

* So <span style="color:red">*name*</span> is of size 32, lets try 31 "1"'s:

    ![image-7.png](./image-7.png)

# Bugs

* As mentioned before, this is a significant vulnerability called "use after free," in which a pointer to freed memory remains in use by a program. Also, <span style="color:red">*strcpy*</span> is vulnerable.





