# Analysis

* We are given with the below source code:

    ![image.png](./image.png)

* Lets try some random inputs:

    ![image-1.png](./image-1.png)

*  We have a buffer overflow on the <span style="color:red">*name*</span> buffer that is allocated on the heap.

    - Just like the stack, heap memory is allocated contiguously. 
    
    - This means that if we write past the buffer, we will be overwriting another data structure.

* Our goal is to execute the <span style="color:red">*winner*</span> function.
# Exploit

* Load this in GDB:

    ![image-2.png](./image-2.png)

* In <main+41>, we examine the address moved into EDX:

    ![image-3.png](./image-3.png)

    - So this is the address of our <span style="color:red">*nowinner*</span> function.

    - Similarly, the address of <span style="color:red">*winner*</span> is 0x8048464.

* Set a breakpoint at the return instruction of main, supply an input and look at the info proc map:

    ![image-4.png](./image-4.png)

* So the heap starts from 0x804a000. Also, at the heap memory, we can see where our "AAAA" input is stored on the heap:

    ![image-5.png](./image-5.png)

* Now, we want to overwrite <span style="color:red">*nowinner*</span>'s address with <span style="color:red">*winner*</span>'s address,  which will then be executed by f->fp().

* Ok, so the f->fp address is 0x0804a050 and the beginning of our d->data buffer is at 0x0804a008. So if we fill d->data with 72 bytes (0x0804a050 - 0x0804a008) plus 4 bytes we want f->fp to be after this (0x8048464):

    ![image-6.png](./image-6.png)   

# The bugs:

* This level is vulnerable because we can pass as many bytes as we want via the <span style="color:red">*name[64]*</span> and the <span style="color:red">*strcpy*</span>:

    ![image-7.png](./image-7.png)


