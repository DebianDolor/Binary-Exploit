# Analysis

* We are given with the below source code:

    ![image.png](./image.png)

* Try some random inputs:

    ![image-1.png](./image-1.png)

* So, there are 3 malloc's and 3 free's in reverse order.

* This level introduces the Doug Lea Malloc (dlmalloc) and how heap meta data can be modified to change program execution. The goal for this level is to call the <span style="color:red">*winner*</span> function.

# Exploit

* As the discription says, this level is about corrupting heap metadata. So there is an issue with the heap algorithm, in this case in the <span style="color:red">*free()*</span> function, that we can use to redirect code execution to <span style="color:red">*winner()*</span>.

* There's a great article on how to implement glibc heap: https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/. 

* Apparently, an allocated chunk will look something like this:

    ![image-2.png](./image-2.png)

* And this is what a freed one looks like:

    ![image-3.png](./image-3.png)

* As you can see, this is some sort of a doubly linked-list. Internally, the heap manager needs to keep track of freed chunks so that malloc can reuse them during allocation requests. This is done by maintaining a series of lists called “bins”, which are designed to maximize speed of allocations and frees.

* And that chunks-consolidation is activated by the call to <span style="color:red">*unlink()*</span>. In fact, <span style="color:red">*unlink*</span> is used in <span style="color:red">*free*</span> to reuse previously allocated memory.

* The chunk is then stored in an <span style="color:red">*unsorted bin*</span>, which is used for temporary storage of freed chunks which reduces the allocator's overhead:

    ![image-4.png](./image-4.png)

* 


# The bugs:

* As mentioned before, this is a significant vulnerability called "use after free," in which a pointer to freed memory remains in use by a program.






