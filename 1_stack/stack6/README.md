
# Analysis

* We are given with the below source code:

    ![image.png](./image.png)

* Try some random inputs:

    ![image-1.png](./image-1.png)

* <span style="color:red">*__builtin_return_address*</span> is a function form the compiler used to read the current return address from the stack. 

* If the return address starts with 0xbf (<span style="color:red">*(ret & 0xbf000000) == 0xbf000000*</span>), then it prints out that return address, and exit.

* In this level, we are unable to overwrite EIP with an arbitrary address due to the <span style="color:red">*ret & 0xbf000000*</span> check.


# Exploit

* Load this in GDB:

    ![image-2.png](./image-2.png)

* Easy seeing, <span style="color:red">*buffer*</span> starts at <span style="color:red">*-0x4c*</span>, which means we need to write 80 bytes (0x4c + 4 bytes of old EBP) plus the 4 bytes we want EIP to be after the <span style="color:red">*ret*</span> instruction.  

* If we use the payload from the <span style="color:red">*stack5*</span> (add leading 0s in the padding due to the <span style="color:red">*unsigned int ret*</span>), it failed:

    ![image-3.png](./image-3.png)

* So we cannot use addresses that start with 0xbf
    





