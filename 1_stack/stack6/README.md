
# Analysis

* We are given with the below source code:

    ![image.png](./image.png)

* Try some random inputs:

    ![image-1.png](./image-1.png)

* <span style="color:red">*__builtin_return_address*</span> is a function from the compiler used to read the current return address from the stack. 

* <span style="color:red">*(ret & 0xbf000000) == 0xbf000000*</span> is used to check if the return address starts with 0xbf or not (Since 0xbf... is the location on the stack that contain executable shellcode).

* When we overflow the <span style="color:red">*buffer*</span> with <span style="color:red">*gets*</span>, we're actually gonna affect the <span style="color:red">*ret*</span> variable, which is then checked. If it starts with 0xbf, then it prints out that return address, and exit.

* Before we move on, I want to address a couple of ways to prevent buffer overflow exploitation: <span style="color:red">*Stack-smashing protection, ASCII armoring, Address space layout randomization (ASLR)*</span> and <span style="color:red">*non-executable stack*</span>. (https://en.wikipedia.org/wiki/Return-to-libc_attack#Protection_from_return-to-libc_attacks)

* Apperantly, a <span style="color:red">*non-executable stack*</span> can prevent some buffer overflow exploitation, however it cannot prevent a <span style="color:red">*ret2libc*</span> attack because in the <span style="color:red">*ret2libc*</span> attack only existing executable code is used.

# Exploit

* Nothing in here that says the stack isn't executable, so the method we used in <span style="color:red">*stack5*</span> is not out of the window completely. But we just can't return to the stack at first. 

* How about the return address? Clearly we can not return back into the stack because the check will kill our process. But we can return back into our program, into the text area. 

* As you can see, <span style="color:red">*getpath()*</span> has a return instruction and if we can put that return instruction at our <span style="color:red">*ret*</span>, what will happen is there will be a return and it will simply return again (returning again to the address below the <span style="color:red">*ret*</span>):

    ![image-4.png](./image-4.png)

* But anyway, we can overwrite the last one (under the <span style="color:red">*ret*</span>) with the address in the middle of NOP (like previous level). 
    
    ![image-6.png](./image-6.png)

* And this will cause a return (or jump) to the NOP, which finally execute our shellcode. So basically we just returning and returning to another address. 

* This <span style="color:red">*ret @getpath*</span> is actually a gadget because it is an executable instruction sequence that is not on the stack (it is on the text area). 

    ![image-7.png](./image-7.png)

* So all that's left to do is to find how many bytes are in the padding and the 2 addresses we want to return to.

* This can be easily done with the help of GDB:

    ![image-2.png](./image-2.png)

* Easy seeing, <span style="color:red">*buffer*</span> starts at <span style="color:red">*ebp-0x4c*</span>, which means we need to write 80 bytes (0x4c + 4 bytes of old EBP) plus the 4 bytes we want EIP to be after the <span style="color:red">*ret*</span> instruction.  

    ![image-8.png](./image-8.png)

    - So, buffer is of size 64 and 0x4c is 76. That means the padding's size is 12. We will fill it with 'a's.

    - Next we have to find <span style="color:red">*ret @getpath*</span>, which is the return address of <span style="color:red">*getpath*</span>. This is quite obvious:

        ![image-10.png](./image-10.png)

    - Lastly, the address at the mid of NOP. NOP is 36 bytes of size, and half of that is 18 (0x12). Also, it starts at <span style="color:red">*ebp-0x4c*</span>, so mid of that is <span style="color:red">*ebp-0x4c+0x12*</span> which is <span style="color:red">*ebp-0x3a*</span>. 

    - Okay so we have to find EBP after it is pointing to the saved EBP (the one in between RET and PADDING). Lets set a breakpoint here after it is assigned with ESP:

        ![image-11.png](./image-11.png)

    - Look at the registers: 

        ![image-15.png](./image-15.png)

    - That's EBP. So now we have to subtract it with 0x3a to find the second return address we're looking for. (0xbffff76e)

    - We will still use the shellcode from the previous level.

* Now lets write our payload:

    ![image-14.png](./image-14.png)

* Boom:

    ![image-13.png](./image-13.png)

* This LiveOverflow's video demonstrates another approach to this (https://www.youtube.com/watch?v=m17mV24TgwY&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=18).

# The bugs:

* Same like previous levels, the bug is at the gets function. And non-executable stack cannot prevent re2libc.
