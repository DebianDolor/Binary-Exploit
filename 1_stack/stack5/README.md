# Analysis

* We are given with the below source code:

    ![image.png](./image.png)

* Try some random inputs:

    ![image-1.png](./image-1.png)

* Ok, this is surprisingly small. And there is only 1 function call to <span style="color:red">*gets*</span>.

* At this point, our goal is to get from no functionality of the program, to the root shell.

* Quick reminder, shellcode is a series of instructions (usually encoded as bytes) that can pwn a shell in applications such as buffer overflow.

# Exploit

* Load this in GDB:

    ![image-2.png](./image-2.png)

    - As can be seen, <span style="color:red">*buffer*</span> is allocated at <span style="color:red">*esp+0x10*</span>.

* We will again try to overwrite the return pointer (since there are no local variables) to point it to our shellcode.

* I use the shellcode here (28 bytes):

    ![image-6.png](./image-6.png)

* I don't quite know what the third line (<span style="color:red">*and esp, 0xfffffff0*</span>) does. So I'll set a breakpoint there and look at the registers:

    ![image-4.png](./image-4.png)

    - So looks like there will be a padding of size 8 allocated under the <span style="color:red">*buffer*</span> (at higher address).

    - Under that, there is EBP, then RET.

* So we will put our shellcode in the <span style="color:red">*buffer*</span> variable, then hope the program will return and start executing the shellcode.

* What I'll do is that I will append the shellcode at the end of the <span style="color:red">*buffer*</span>. And before it (at lower address), we have to make sure that these are not random bytes. Because if it is, and we run in different directory (which will be discussed after this), it may not jump to the shellcode, but these random bytes instead!

    - So we'll going to use NOP (No-Operation).

    - Imagine, you're at the top of the hill, and you throw a ball. Down the hill, is our shellcode. So when it reaches the end, it will execute the shellcode. NOP will actually do it for us. But we need something to throw, right? And that, specifically, is an address. 

    - We have to find the address of somewhere halfway within this NOP. And the reason for halfway is that if we placed it at the begining or at the bottom of our NOP and we run in a different directory, we could be jumping somewhere above or under our buffer.  
    
    - The remaining size of <span style="color:red">*NOP*</span> is 64-28=36 bytes. So we should be aiming for 18 (0x12). So we will want esp+0x10+0x12 = esp+0x22. This is where we'll store our return address. 

    - After <span style="color:red">*sup esp, 0x50*</span>, it's value will be:

        ![image-5.png](./image-5.png)

    - So, 0xbffff650 + 0x22 = 0xbffff782, is our desired return address. 

* I will draw everything out real quick:

    ![image-3.png](./image-3.png)

* Now lets write our exploit code:

    ![image-7.png](./image-7.png)

    - We will fill the padding (the green one) with "a" * 8 and our EBP (since it's 4 bytes) with "b" * 4.

    - NOP is 0x90.

* Runs like butter:

    ![image-8.png](./image-8.png)


* Note: If you run the same payload in a different directory, it may work differently. This is because environment variables are stored on the stack. But what if our stack directory has more or fewer environment variables than other directories? It will jump to a different location other than our shellcode. Thus does not run as it may.

# The bugs:

* Same as previous level, the bug is at the <span style="color:red">*gets*</span> function.


    





