# Analysis

* We are given with the below source code:

    ![image.png](./image.png)

* Try some random inputs:

    ![image-1.png](./image-1.png)

* It returns some weird address.

# Exploit

* Go ahead and open it in GDB and disassemble the main function:

    ![image-2.png](./image-2.png)

* The frist few lines are the same as <span style="color:red">*stack0*</span>. So lets try that exploit code in here:

    ![image-4.png](./image-4.png)

* As you can see, the hex value of "a" (which is 41) is written to the memory allocated for the <span style="color:red">*modified*</span> variable. This means that we can write 4 bytes past the space allocated for <span style="color:red">*buffer*</span> to contain whatever byte value we want. 

* Since there is a check: 
    
    ![image-5.png](./image-5.png) 

    - We will append 0x61626364 to the end of our exploit string. But notice that x86 is little-endian, we will put 0x64636261 at the end of the string, which in ASCII is <span style="color:red">*dcba*</span>.

* Result:

    ![image-6.png](./image-6.png)

# The bugs:

* Again, take a look at the <span style="color:red">*man*</span> page for <span style="color:red">*strcpy*</span>, it says: <span style="color:red">*"Over‚Äê
       flowing  fixed-length  string buffers is a favorite
       cracker technique for taking  complete  control  of
       the  machine."*</span>

    ![image-7.png](./image-7.png)
    




