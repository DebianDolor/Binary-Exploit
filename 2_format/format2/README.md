
# Analysis

* We are given with the below source code:

    ![image.png](./image.png)

* Try some random inputs:

    ![image-1.png](./image-1.png)

* Everything is similar to <span style="color:red">*format1*</span>, except that we now have to write a specific value to <span style="color:red">*target*</span>. 

* <span style="color:red">*fgets()*</span> doesn't allow us to write more bytes than the length we provide. So we can't do a buffer overflow here. But then the input is passed directly to <span style="color:red">*printf()*</span>, which is vulnerable to format string exploit.

# Exploit

* Lets find the address of <span style="color:red">*target*</span> with GDB:

    ![image-2.png](./image-2.png)

* We locate the start of our input string. This time, it's much easier since it gets copied to a buffer in the same stack frame as our <span style="color:red">*printf()*</span> function:

    ![image-3.png](./image-3.png)

* Now replace "AAAA" with the address we've just found:

    ![image-4.png](./image-4.png)

* This is easy, we just have to fill whatever's left with "a"s:

    ![image-5.png](./image-5.png)

* But let me show u a cool trick: we can use <span style="color:red">*%nu*</span> where n is a number that we can manipulate to write the number of bytes we want. So start with this:

    ![image-6.png](./image-6.png)

* Simple math, we need %47u:

    ![image-7.png](./image-7.png)


# The bugs:

* The vulnerability is at the <span style="color:red">*printf*</span> function (like in the previous level).


